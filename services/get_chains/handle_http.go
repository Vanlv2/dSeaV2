package get_chains

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"math/big"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/ethereum/go-ethereum/rpc"
)

func extractTransactionData(tx map[string]interface{}, chainName string, blockTime string) map[string]interface{} {
	logData := make(map[string]interface{})

	// L·∫•y d·ªØ li·ªáu c∆° b·∫£n t·ª´ transaction
	txHash, _ := tx["hash"].(string)
	from, _ := tx["from"].(string)
	to, _ := tx["to"].(string)
	blockNumberHex, _ := tx["blockNumber"].(string)
	input, _ := tx["input"].(string)
	valueHex, _ := tx["value"].(string)

	// Chuy·ªÉn ƒë·ªïi gi√° tr·ªã v√† block number
	value := new(big.Int)
	if len(valueHex) > 2 {
		value.SetString(valueHex[2:], 16)
	}

	blockNumber := new(big.Int)
	if len(blockNumberHex) > 2 {
		blockNumber.SetString(blockNumberHex[2:], 16)
	}

	// C·∫•u tr√∫c d·ªØ li·ªáu ƒë·ªÉ l∆∞u v√†o database
	logData["name_chain"] = chainName
	logData["timestamp"] = blockTime
	logData["block_number"] = blockNumber.Uint64()
	logData["tx_hash"] = txHash
	logData["address"] = to
	logData["from_address"] = from
	logData["to_address"] = to
	logData["amount"] = value.String()
	logData["raw_data"] = fmt.Sprintf("%v", tx)

	// X·ª≠ l√Ω input data v√† signature
	if len(input) >= 10 {
		logData["event_signature"] = input[:10]

		// Ph√¢n t√≠ch event signature ƒë·ªÉ l·∫•y transaction_type
		if transactionType, err := Parse_event_signature_name(input[:10]); err == nil {
			logData["transaction_type"] = transactionType
		} else {
			log.Printf("Kh√¥ng th·ªÉ parse event signature %s: %v", input[:10], err)
			logData["transaction_type"] = "Unknown"
		}
	} else {
		logData["event_signature"] = ""
		logData["transaction_type"] = "Transfer"
	}

	return logData
}

func importLogFileToDatabase(logFilePath string, chainName string) error {
	log.Printf("üîÑ B·∫Øt ƒë·∫ßu nh·∫≠p d·ªØ li·ªáu t·ª´ file %s v√†o database...", logFilePath)

	data, err := os.ReadFile(logFilePath)
	if err != nil {
		return fmt.Errorf("kh√¥ng th·ªÉ ƒë·ªçc file log: %v", err)
	}

	// T√°ch file th√†nh c√°c block ri√™ng bi·ªát
	blocks := strings.Split(string(data), "----------------------------------------")

	for _, blockData := range blocks {
		if strings.TrimSpace(blockData) == "" {
			continue
		}

		lines := strings.Split(blockData, "\n")
		if len(lines) < 2 {
			continue
		}

		// Parse d√≤ng header ƒë·ªÉ l·∫•y th√¥ng tin block
		headerLine := strings.TrimSpace(lines[0])
		headerParts := strings.Split(headerLine, "] ")
		if len(headerParts) < 2 {
			continue
		}

		timestamp := strings.Trim(headerParts[0], "[")
		blockInfo := headerParts[1]

		blockNumberStr := ""
		if parts := strings.Split(blockInfo, ", "); len(parts) > 0 {
			blockNumberStr = strings.TrimPrefix(parts[0], "Block: ")
		}

		// Parse JSON block data
		var block map[string]interface{}
		jsonStart := strings.Index(blockData, "{")
		if jsonStart == -1 {
			continue
		}

		jsonData := blockData[jsonStart:]
		if err := json.Unmarshal([]byte(jsonData), &block); err != nil {
			log.Printf("L·ªói khi parse JSON c·ªßa block: %v", err)
			continue
		}

		// L·∫•y transactions t·ª´ block
		transactions, ok := block["transactions"].([]interface{})
		if !ok {
			continue
		}

		for _, tx := range transactions {
			txMap, ok := tx.(map[string]interface{})
			if !ok {
				continue
			}

			// Tr√≠ch xu·∫•t d·ªØ li·ªáu transaction
			logData := extractTransactionData(txMap, chainName, timestamp)
			blockNumber, _ := new(big.Int).SetString(blockNumberStr, 10)
			if blockNumber != nil {
				logData["block_number"] = blockNumber.Uint64()
			}
		}
	}

	log.Printf("‚úÖ Ho√†n th√†nh nh·∫≠p d·ªØ li·ªáu t·ª´ file %s v√†o database", logFilePath)
	return nil
}

// H√†m ghi block v√†o file
func write_block_to_file(blockNumber *big.Int, block map[string]interface{}, txCount int, chainName string) {
	filePath := fmt.Sprintf("./services/get_chains/block_data_%s.log", chainName)
	file, err := os.OpenFile(filePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		log.Printf("Kh√¥ng th·ªÉ m·ªü file %s: %v", filePath, err)
		return
	}
	defer file.Close()

	timestamp := time.Now().Format("2006-01-02 15:04:05")
	blockData := fmt.Sprintf("[%s] Block: %s, Transactions: %d\n", timestamp, blockNumber.String(), txCount)

	blockJSON, err := json.MarshalIndent(block, "", "  ")
	if err != nil {
		log.Printf("Kh√¥ng th·ªÉ chuy·ªÉn ƒë·ªïi block th√†nh JSON: %v", err)
	} else {
		blockData += string(blockJSON) + "\n----------------------------------------\n"
	}

	if _, err := file.WriteString(blockData); err != nil {
		log.Printf("Kh√¥ng th·ªÉ ghi v√†o file %s: %v", filePath, err)
	} else {
		log.Printf("ƒê√£ ghi kh·ªëi %s (%d giao d·ªãch) v√†o file cho chain %s", blockNumber.String(), txCount, chainName)
	}
}

// H√†m ghi transaction v√†o file
func writeTransactionToFile(tx map[string]interface{}) {
	txHash, _ := tx["hash"].(string)
	if txHash == "" {
		log.Printf("B·ªè qua ghi log cho giao d·ªãch kh√¥ng c√≥ hash")
		return
	}

	filePath := "./transactions.log"
	file, err := os.OpenFile(filePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		log.Printf("Kh√¥ng th·ªÉ m·ªü file %s: %v", filePath, err)
		return
	}
	defer file.Close()

	timestamp := time.Now().Format("2006-01-02 15:04:05")
	txData := fmt.Sprintf("[%s] Transaction: %s\n", timestamp, txHash)

	txJSON, err := json.MarshalIndent(tx, "", "  ")
	if err != nil {
		log.Printf("Kh√¥ng th·ªÉ chuy·ªÉn ƒë·ªïi transaction th√†nh JSON: %v", err)
	} else {
		txData += string(txJSON) + "\n----------------------------------------\n"
	}

	if _, err := file.WriteString(txData); err != nil {
		log.Printf("Kh√¥ng th·ªÉ ghi v√†o file %s: %v", filePath, err)
	} else {
		log.Printf("ƒê√£ ghi giao d·ªãch %s v√†o file", txHash)
	}
}

// X·ª≠ l√Ω block
func processBlock(client *rpc.Client, blockNumber *big.Int, chainName string) error {
	var block map[string]interface{}
	blockHex := fmt.Sprintf("0x%x", blockNumber)

	log.Printf("üîç ƒêang l·∫•y th√¥ng tin kh·ªëi: %s", blockHex)

	err := client.Call(&block, "eth_getBlockByNumber", blockHex, true)
	if err != nil {
		log.Printf("‚ùå L·ªói khi l·∫•y kh·ªëi %s: %v", blockHex, err)
		return err
	}

	log.Printf("‚úÖ ƒê√£ l·∫•y kh·ªëi: %s - %s", blockHex, blockNumber.String())

	if block["transactions"] == nil {
		log.Printf("‚ö†Ô∏è Kh·ªëi %s kh√¥ng c√≥ giao d·ªãch n√†o", blockHex)
		return fmt.Errorf("kh√¥ng t√¨m th·∫•y giao d·ªãch")
	}

	transactions := block["transactions"].([]interface{})
	txCount := len(transactions)

	// L·∫•y th·ªùi gian c·ªßa block
	blockTimeHex, _ := block["timestamp"].(string)
	blockTimeInt := new(big.Int)
	if len(blockTimeHex) > 2 {
		blockTimeInt.SetString(blockTimeHex[2:], 16)
	}

	write_block_to_file(blockNumber, block, txCount, chainName)

	log.Printf("üîÑ ƒêang x·ª≠ l√Ω %d giao d·ªãch t·ª´ kh·ªëi %s", txCount, blockNumber.String())

	for i, tx := range transactions {
		txMap := tx.(map[string]interface{})
		txHash, _ := txMap["hash"].(string)
		log.Printf("   üìù X·ª≠ l√Ω giao d·ªãch (%d/%d): %s", i+1, txCount, txHash)

		// V·∫´n gi·ªØ l·∫°i vi·ªác ghi log ra file n·∫øu c·∫ßn
		writeTransactionToFile(txMap)
	}

	log.Printf("‚úÖ Ho√†n th√†nh x·ª≠ l√Ω kh·ªëi %s - %s", blockHex, blockNumber.String())
	return nil
}

func importAllLogFiles() {
	chains := []string{"bsc", "avalanche"}

	for _, chain := range chains {
		logFilePath := fmt.Sprintf("./block_data_%s.log", chain)
		if _, err := os.Stat(logFilePath); err == nil {
			log.Printf("T√¨m th·∫•y file log cho chain %s, b·∫Øt ƒë·∫ßu nh·∫≠p d·ªØ li·ªáu...", chain)
			if err := importLogFileToDatabase(logFilePath, chain); err != nil {
				log.Printf("‚ùå L·ªói khi nh·∫≠p d·ªØ li·ªáu t·ª´ %s: %v", logFilePath, err)
			}
		}
	}
}

// X·ª≠ l√Ω transaction
func processTransaction(tx map[string]interface{}, chainName string) {
	to, ok := tx["to"].(string)
	if !ok || to == "" {
		log.Printf("   ‚è© B·ªè qua giao d·ªãch t·∫°o h·ª£p ƒë·ªìng")
		return
	}

	txHash, ok := tx["hash"].(string)
	if !ok || txHash == "" {
		log.Printf("   ‚è© B·ªè qua giao d·ªãch kh√¥ng h·ª£p l·ªá")
		return
	}

	toAddress := strings.ToLower(to)
	valueHex, _ := tx["value"].(string)
	value := new(big.Int)
	if len(valueHex) > 2 {
		value.SetString(valueHex[2:], 16)
	}

	input, _ := tx["input"].(string)
	from, _ := tx["from"].(string)

	log.Printf("   üíº Giao d·ªãch: %s", txHash)
	log.Printf("   üì§ T·ª´: %s", from)
	log.Printf("   üì• ƒê·∫øn: %s", toAddress)
	log.Printf("   üí∞ Gi√° tr·ªã: %s wei", value.String())

	chainData := GetChainData(chainName)
	if chainData == nil {
		log.Printf("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho chain %s", chainName)
		return
	}

	if len(input) >= 10 && input[:10] == chainData.Config.TransferSignature {
		log.Printf("üí∞ GIAO D·ªäCH TRANSFER PH√ÅT HI·ªÜN üí∞")
		log.Printf("   Chain: %s", chainName)
		log.Printf("   Contract: %s", toAddress)
		log.Printf("   TxHash: %s", txHash)
		log.Printf("   Input: %s", input[:20]+"...")

		process_transfer_and_save(chainName, tx)
	}
}

// X·ª≠ l√Ω v√† l∆∞u th√¥ng tin transfer
func process_transfer_and_save(chainName string, tx map[string]interface{}) {
	chainData := GetChainData(chainName)
	if chainData == nil {
		log.Printf("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho chain %s", chainName)
		return
	}

	blockTimeHex, _ := tx["timestamp"].(string)
	if blockTimeHex == "" {
		blockTimeHex = "0x" + strconv.FormatInt(time.Now().Unix(), 16)
	}

	blockTimeInt := new(big.Int)
	if len(blockTimeHex) > 2 {
		blockTimeInt.SetString(blockTimeHex[2:], 16)
	}
	blockTime := time.Unix(blockTimeInt.Int64(), 0).Format("2006-01-02 15:04:05")

	// Tr√≠ch xu·∫•t d·ªØ li·ªáu
	logData := extractTransactionData(tx, chainName, blockTime)

	// C·∫≠p nh·∫≠t LogData c·ªßa chain
	chainData.LogData = logData
}

// H√†m duy·ªát ng∆∞·ª£c t·ª´ th·ªùi gian hi·ªán t·∫°i v·ªÅ qu√° kh·ª©
func processBlocksInReverse(client *rpc.Client, pastDuration time.Duration) (map[string]interface{}, error) {
	// T√≠nh to√°n th·ªùi gian m·ª•c ti√™u
	targetTime := time.Now().Add(-pastDuration)

	// L·∫•y block hi·ªán t·∫°i
	var latestBlockHex string
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	err := client.CallContext(ctx, &latestBlockHex, "eth_blockNumber")
	cancel()
	if err != nil {
		return nil, fmt.Errorf("l·ªói khi l·∫•y block hi·ªán t·∫°i: %v", err)
	}

	latestBlock := new(big.Int)
	latestBlock.SetString(latestBlockHex[2:], 16)

	// Kh·ªüi t·∫°o map ƒë·ªÉ l∆∞u d·ªØ li·ªáu
	blockDataMap := make(map[string]interface{})

	// Duy·ªát ng∆∞·ª£c t·ª´ block hi·ªán t·∫°i v·ªÅ qu√° kh·ª©
	for {
		var block map[string]interface{}
		blockHex := fmt.Sprintf("0x%x", latestBlock)

		err := client.Call(&block, "eth_getBlockByNumber", blockHex, true)
		if err != nil {
			log.Printf("‚ùå L·ªói khi l·∫•y kh·ªëi %s: %v", blockHex, err)
			break
		}

		// L·∫•y th·ªùi gian c·ªßa block
		blockTimeHex, _ := block["timestamp"].(string)
		blockTimeInt := new(big.Int)
		if len(blockTimeHex) > 2 {
			blockTimeInt.SetString(blockTimeHex[2:], 16)
		}
		blockTime := time.Unix(blockTimeInt.Int64(), 0)
		fmt.Printf("Th·ªùi gian c·ªßa block: %s", blockTime)

		// Ki·ªÉm tra n·∫øu blockTime nh·ªè h∆°n ho·∫∑c b·∫±ng targetTime th√¨ d·ª´ng
		if blockTime.Before(targetTime) || blockTime.Equal(targetTime) {
			break
		}

		// Thu th·∫≠p d·ªØ li·ªáu c·ªßa block v√†o map
		blockDataMap[blockHex] = block

		// Gi·∫£m s·ªë block ƒë·ªÉ duy·ªát ng∆∞·ª£c
		latestBlock.Sub(latestBlock, big.NewInt(1))
	}

	return blockDataMap, nil
}

// Kh·ªüi ƒë·ªông x·ª≠ l√Ω HTTP
func continueHandleHTTP(client *ethclient.Client, chainName string) {
	chainData := GetChainData(chainName)
	if chainData == nil {
		log.Fatalf("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho chain %s", chainName)
	}

	// Kh·ªüi t·∫°o block b·∫Øt ƒë·∫ßu (c√≥ th·ªÉ c·∫•u h√¨nh trong file)
	blockNumber := big.NewInt(21604935)
	chainData.LastProcessedBlock = new(big.Int).Set(blockNumber)
	chainData.LastProcessedBlock.Sub(chainData.LastProcessedBlock, big.NewInt(1))

	log.Printf("======= KH·ªûI ƒê·ªòNG H·ªÜ TH·ªêNG CHO CHAIN %s =======", chainName)
	log.Printf("Kh·ªüi t·∫°o lastProcessedBlock = %d", chainData.LastProcessedBlock)
	log.Printf("B·∫Øt ƒë·∫ßu qu√©t t·ª´ kh·ªëi = %d", blockNumber)
	log.Printf("TransferSignature: %s", chainData.Config.TransferSignature)
	log.Printf("==================================")

	blockCounter := 0
	rpcClient := client.Client()

	for {
		blockCounter++

		// M·ªói 50 kh·ªëi, ki·ªÉm tra xem c√≥ b·ªã b·ªè l·ª° kh·ªëi n√†o kh√¥ng
		if blockCounter%50 == 0 {
			var latestBlockHex string
			ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			err := rpcClient.CallContext(ctx, &latestBlockHex, "eth_blockNumber")
			cancel()

			if err == nil {
				latestBlock := new(big.Int)
				latestBlock.SetString(latestBlockHex[2:], 16)

				gap := new(big.Int).Sub(latestBlock, blockNumber)
				if gap.Cmp(big.NewInt(20)) > 0 {
					// C√≥ kho·∫£ng c√°ch l·ªõn, x·ª≠ l√Ω nhanh c√°c kh·ªëi b·ªã b·ªè l·ª°
					nextBatchEnd := new(big.Int).Add(blockNumber, big.NewInt(100))
					if nextBatchEnd.Cmp(latestBlock) > 0 {
						nextBatchEnd.Set(latestBlock)
					}

					log.Printf("‚ö†Ô∏è Ph√°t hi·ªán kho·∫£ng c√°ch %d kh·ªëi tr√™n chain %s. ƒêang qu√©t nhanh t·ª´ %d ƒë·∫øn %d...",
						gap, chainName, blockNumber, nextBatchEnd)

					for i := new(big.Int).Set(blockNumber); i.Cmp(nextBatchEnd) <= 0; i.Add(i, big.NewInt(1)) {
						if err := processBlock(rpcClient, i, chainName); err != nil {
							log.Printf("L·ªói khi x·ª≠ l√Ω kh·ªëi %d: %v, ti·∫øp t·ª•c...", i, err)
						}
						time.Sleep(50 * time.Millisecond)
					}

					blockNumber.Set(nextBatchEnd)
					blockNumber.Add(blockNumber, big.NewInt(1))

					processLock.Lock()
					chainData.LastProcessedBlock.Set(nextBatchEnd)
					processLock.Unlock()

					log.Printf("‚úÖ ƒê√£ qu√©t nhanh ƒë·∫øn kh·ªëi %d", nextBatchEnd)
					continue
				}
			}
		}

		// X·ª≠ l√Ω kh·ªëi ti·∫øp theo
		err := processBlock(rpcClient, blockNumber, chainName)
		if err == nil {
			blockNumber = new(big.Int).Add(blockNumber, big.NewInt(1))

			processLock.Lock()
			if blockNumber.Cmp(chainData.LastProcessedBlock) > 0 {
				chainData.LastProcessedBlock = new(big.Int).Set(blockNumber)
				chainData.LastProcessedBlock.Sub(chainData.LastProcessedBlock, big.NewInt(1))
			}
			processLock.Unlock()

			time.Sleep(200 * time.Millisecond)
		} else {
			sleepTime := time.Duration(chainData.Config.TimeNeedToBlock) * time.Millisecond
			if sleepTime < 500*time.Millisecond {
				sleepTime = 500 * time.Millisecond
			}
			log.Printf("ƒê·ª£i %v tr∆∞·ªõc khi th·ª≠ l·∫°i kh·ªëi %d", sleepTime, blockNumber)
			time.Sleep(sleepTime)
		}
	}
}

func reverseHandleHTTP(client *ethclient.Client, chainName string, pastDuration time.Duration) {
	chainData := GetChainData(chainName)
	if chainData == nil {
		log.Fatalf("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho chain %s", chainName)
	}

	// K·∫øt n·ªëi ƒë·∫øn RPC client
	rpcClient := client.Client()

	// L·∫•y block hi·ªán t·∫°i ƒë·ªÉ b·∫Øt ƒë·∫ßu qu√©t ng∆∞·ª£c
	var latestBlockHex string
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	err := rpcClient.CallContext(ctx, &latestBlockHex, "eth_blockNumber")
	cancel()
	if err != nil {
		log.Fatalf("L·ªói khi l·∫•y block hi·ªán t·∫°i: %v", err)
	}

	// Chuy·ªÉn ƒë·ªïi t·ª´ hex sang big.Int
	blockNumber := new(big.Int)
	blockNumber.SetString(latestBlockHex[2:], 16)

	// T√≠nh th·ªùi gian m·ª•c ti√™u
	targetTime := time.Now().Add(-pastDuration)

	log.Printf("======= KH·ªûI ƒê·ªòNG H·ªÜ TH·ªêNG NG∆Ø·ª¢C CHO CHAIN %s =======", chainName)
	log.Printf("B·∫Øt ƒë·∫ßu qu√©t t·ª´ kh·ªëi hi·ªán t·∫°i = %d", blockNumber)
	log.Printf("Th·ªùi gian m·ª•c ti√™u: %v", targetTime)
	log.Printf("TransferSignature: %s", chainData.Config.TransferSignature)
	log.Printf("==================================")

	blockCounter := 0

	for {
		
		blockCounter++

		// X·ª≠ l√Ω kh·ªëi hi·ªán t·∫°i
		err := processBlock(rpcClient, blockNumber, chainName)
		if err == nil {
			// L·∫•y th·ªùi gian c·ªßa block ƒë·ªÉ ki·ªÉm tra ƒëi·ªÅu ki·ªán d·ª´ng
			var block map[string]interface{}
			blockHex := fmt.Sprintf("0x%x", blockNumber)

			if err := rpcClient.Call(&block, "eth_getBlockByNumber", blockHex, false); err == nil {
				fmt.Println("Block:", block)
				// L·∫•y th·ªùi gian c·ªßa block
				blockTimeHex, _ := block["timestamp"].(string)
				blockTimeInt := new(big.Int)
				if len(blockTimeHex) > 2 {
					blockTimeInt.SetString(blockTimeHex[2:], 16)
				}
				blockTime := time.Unix(blockTimeInt.Int64(), 0)
				
				// Ki·ªÉm tra n·∫øu ƒë√£ ƒë·∫°t ƒë·∫øn th·ªùi gian m·ª•c ti√™u
				if blockTime.Before(targetTime) || blockTime.Equal(targetTime) {
					log.Printf("‚úÖ ƒê√£ ƒë·∫°t ƒë·∫øn th·ªùi gian m·ª•c ti√™u t·∫°i kh·ªëi %d", blockNumber)
					break
				}
			}
			// Gi·∫£m s·ªë block ƒë·ªÉ qu√©t ng∆∞·ª£c v·ªÅ qu√° kh·ª©
			blockNumber = new(big.Int).Sub(blockNumber, big.NewInt(1))

			// C·∫≠p nh·∫≠t LastProcessedBlock
			processLock.Lock()
			chainData.LastProcessedBlock = new(big.Int).Set(blockNumber)
			chainData.LastProcessedBlock.Add(chainData.LastProcessedBlock, big.NewInt(1))
			processLock.Unlock()

			// M·ªói 50 kh·ªëi, in th√¥ng tin ti·∫øn ƒë·ªô
			if blockCounter%50 == 0 {
				log.Printf("üîÑ ƒê√£ qu√©t ng∆∞·ª£c %d kh·ªëi, hi·ªán t·∫°i ·ªü kh·ªëi %d", blockCounter, blockNumber)
			}

			time.Sleep(200 * time.Millisecond)
		} else {
			sleepTime := time.Duration(chainData.Config.TimeNeedToBlock) * time.Millisecond
			if sleepTime < 500*time.Millisecond {
				sleepTime = 500 * time.Millisecond
			}
			log.Printf("ƒê·ª£i %v tr∆∞·ªõc khi th·ª≠ l·∫°i kh·ªëi %d", sleepTime, blockNumber)
			time.Sleep(sleepTime)
		}
	}

	log.Printf("‚úÖ Ho√†n th√†nh x·ª≠ l√Ω c√°c block ng∆∞·ª£c cho chain %s", chainName)
}

// X·ª≠ l√Ω chain qua HTTP
func handle_chain_http(chainName string) {
	chainData := InitChainData(chainName)
	load_config(chooseChain[chainName], chainName)

	client, err := ethclient.Dial(chainData.Config.WssRPC)
	if err != nil {
		log.Fatalf("Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn RPC cho %s: %v", chainName, err)
	}
	defer client.Close()
	pastDuration := 1 * time.Hour

	// reverseHandleHTTP(client, chainName, pastDuration)
	reverseHandleHTTP(client, chainName, pastDuration)

	// continueHandleCosmosHTTP(chainName)
}

func handle_http() {
	// Tr∆∞·ªõc ti√™n, nh·∫≠p d·ªØ li·ªáu t·ª´ file log v√†o database (n·∫øu c√≥)
	go importAllLogFiles()

	// Sau ƒë√≥ ti·∫øp t·ª•c v·ªõi c√°c chain
	chains := []string{
		"ethereum",
		"bsc",
		"avalanche",
		"polygon",
		"arbitrum",
		"optimism",
		"fantom",
		"base",
	}

	for _, chain := range chains {
		go handle_chain_http(chain)
	}

	// Gi·ªØ cho ch∆∞∆°ng tr√¨nh ch·∫°y m√£i
	select {}
}
